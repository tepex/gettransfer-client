# О проекте GetTransfer и не только.

## 1. О проекте
Проект мобильного Андроид-приложения создается для предоставления услуг трансфера из точки А в точку Б.  
Все примерно также, как в приложениях заказа такси.

## 2. Структура проекта
Проект строится по принципам Clean Architecture (CA), SOLID, MVP. Язык разработки — Kotlin.  
В соответствии с ппарадигмой CA, проект разбит на 3 gradle-модуля по слоям CA:  
* presentation  
* domain  
* data  

Слой **domain** — это ядро приложения. В нем сосредоточена бизнес-логика. Он самый чистый 
и независимый. В том смысле, что он ничего не должен знать об окружающем мире. В нем только
стандартные Java-классы. С внешним миром он общается через свои интерфейсы, которые 
имплементируются в других слоях. Сакральный смысл этого — возможность выдрать этот слой и 
поместить в любое другое окружение. Например, заменить слой **data** который работал с БД,
на слой **data**, который работает с REST. Или заменить Андроидовский слой **presentation** 
на слой **presentation** интерфейса командной строки. При этом сам слой **domain** не 
меняется и не пересобирается. Связывание слоев осуществляется с помощью DI (Dagger, Koin). 
Нужно, в первую очередь, для устранения жестких связей между копонентами системы и для 
Unit-тестирования.  

В каждом слое по идее должны быть свои модели (POJO) с которыми этот слой работает. Т.е.    
данные от сервера к пользователю идут по такому пути:  
сервер -> **Data** -> **Domain** -> **Presentation** -> UI  

На каждом из этапов данные преобразуются в соответствующую модель с помощью мапперов. Это 
нужно для того, чтобы слои работали только со своими родными типами данных и тем самым 
были максимально независимы друг от друга. Например, в данном проекте есть модель «геолокация»,
которая определяется с помощью latitude и longitude. Для каждого из 3-х слоев это 3 разных
класса: LatLng (**presentation**), Point (**domain**), Location (**data**). Хотя, по сути,
это одно и тоже. На практике это зачастую может оказываться избыточным и используют один 
или два типа для всех слоев.  

### Подитог
Стоит сказать, что эти 3 слоя — не догма, а общий ориентир при проектировании архитектуры
и каждый реализует подход CA под свои конкретные задачи руководствуясь разумным балансом.
В будущем, при росте проекта, когда кол-во фич станет несколько десятков, применяют
разбиение проекта по фичам: одна фича (группа фич) — один модуль. Внутри каждого модуля
разбиение на слои CA.

## 3. Фреймворки
Moxy — реализация MVP для слоя **presentation**.  
Cicerone — для навигации (переходов) между экранами.  
Koin — DI  
Timber — логгер  
Вместо Butterknife используется расширение kotlinx.android.synthetic  
Для асинхронного взаимодействия вместо RxJava используются корутины  

## 4. Процесс разработки
Основной ствол в репозитории — `dev`. Ветку `master` не трогаем — она для релизов. Порядок
примерно такой:
```
$ git checkout dev
$ git pull
```
Берем задачу(и) из Jira, меняем статус задачи на "В работе".  
Создаем ветку с релевантным названием (например, как номер задачи)  
code... code... code...   
Не забывать регулярно синхронизировать свою рабочую ветку с `dev` если работа в текущей ветке
затянулась и ветка рассинхронизировалась с основным стволом на несколько дней   
[merge & rebase](https://blog.algolia.com/master-git-rebase/)  
но помним о [золотом правиле!](https://medium.freecodecamp.org/git-rebase-and-the-golden-rule-explained-70715eccc372)  
```
$ git commit -am 'my commit'
$ git push -u origin my-branch-name
```
В GitLab:
```
pull request  
code review
Сливаем с веткой `dev`
```
Меняем статус задачи на "Done"  
В дальнейшем процесс будет организован по спринтам (наверное, 2-х недельным). Один день из
спринта резервируем как "санитарный день" для рефакторинга и технических долгов.  
Cтараемся придерживаться стиля кода как в котлиновской документации. Когда дойдут руки —
прикручу gradle-плагин для автоматической проверки code style.

## 5. Ссылки
* [Доступ к элементам UI по-котлиновски](https://antonioleiva.com/kotlin-android-extensions/)
* [Корутины вместо RxJava](https://medium.com/@andrea.bresolin/playing-with-kotlin-in-android-coroutines-and-how-to-get-rid-of-the-callback-hell-a96e817c108b)
* [Coroutines vs RxJava](https://medium.com/capital-one-developers/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a)
